chunk_id,content
1,"МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ  
 НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ «ЛЬВІВСЬКА ПОЛІТЕХНІКА»  
 
Інститут комп'ютерних наук та інформаційних технологій  
Кафедра систем штучного інтелекту  
 
 
 
Звіт 
Лабораторна робота № 4 
з курсу “Моделювання та аналіз даних в інформаційних системах”  
 
 
 
 
Виконала:  
студентка групи  ШІ-32 
Якимів Анастасія  
 
Викладач:  
Пелещишин О.П.  
 
Львів 2024р."
2,"Тема: Симуляція різних типів СМО за допомогою SimPy  
Мета:  Дослідження різнотипних СМО за допомогою SimPy  
 
Завдання:   
Індивідуальні завдання (обрати собі задачу з переліку – в групі задачі не повинні 
повторюватись). Для кожної задачі підібрати той варіант СМО (див. Варіанти СМО), який 
її характеризує  
Обрати варіант СМО : 
1. СМО з втратами та без очікування  
2. Багатоканальні СМО з втратами та без очікування  
3. СМО з очікуванням (багатоканальні пристрої)  
4. СМО з повторними викликами та обмеженою кількістю місць в черзі  
Залежно від варіанту,  потрібно : 
 Побудувати та записати модель СМО у вигляді блок -схеми.  
 Реалізувати модель в Python, використовуючи SimPy.  
 Виконати імітаційне моделювання. Включіть у звіт код програми, результати 
моделювання та короткий аналіз отриманих результатів.  
 Виконати покрокове виконання моделі та додати знімки з підтвердженням 
правильності алгоритму.  
 
Вихідні дані залежать від прізвища  
 
Хід роботи"
3,"Хід роботи  
 
Для даної лабораторної роботи я обрала задачу - система пошуку збоїв у 
банківській мережі .  
Задачу ""Система пошуку збоїв у банківській мережі"" можна віднести до СМО 
з повторними викликами та очікуванням в черзі з обмеженою кількістю місць 
в черзі (варіант 4). Такий варіант підходить через специфіку задачі:  
- Повторні виклики — у разі виявлення збою система може повторювати 
перевірки або запити, щоб підтвердити чи вирішити проблему.  
- Черга з обмеженою кількістю місць — мережа може обр обляти обмежену 
кількість запитів одночасно, і якщо черга переповнюється, деякі запити 
можуть втрачатися, або користувачам доведеться повторно намагатися 
підключитися.  
 
Це дозволить змоделювати поведінку системи, в якій відбувається 
моніторинг мережі, з ур ахуванням обмежень на кількість місць у черзі та 
можливих повторних перевірок для стабільності роботи.  
 
Вихідні дані:  
У даному варіанті СМО в ихідні дані визначаються, як:  
 
 
Моє прізвище – Якимів"
4,"Моє прізвище – Якимів  
 
Розрахуємо вихідні дані на основі  мого  прізвища:  
1. Кількість літер у прізвищі (Кп):  
   - У прізвищі Якимів  6 букв , отже, Кп = 6  
 
2. Кількість голосних літер (Кг):  
   - Голосні в прізвищі: ""я"", ""и"", ""і"" , отже Кг = 3  
 
3. Кількість приголосних літер (Кприг):  
   -Приголосні в прізвищі: ""к"", ""м"", ""в"" , отже Кпри г = 3"
5,"Вихідні дані:  
1. Кількість заявок: 200 * Кп = 200 * 6 = 1200 заявок  
2. Кількість обслуговуючих каналів  (Кг): 3  
3. Кількість місць у черзі (Кприг): 3  
 
Тепер ці дані можна використовувати для реалізації обраної моделі в SimPy.  
 
Побудувати та записати  модель СМО у вигляді блок -схеми : 
Табличний опис блок -схеми:  
Етап  Опис  
Вхідний запит  Запит надходить у систему для 
обслуговування  
Чи є вільний обслуговуючий канал ? Перевіряється, чи є доступний обслуговуючий 
канал  (з 3 каналів ) 
Так Якщо є вільний канал , запит переходить на 
обробку  
Ні Якщо всі канали  зайняті, запит надходить у 
чергу очікування  
Чи є місце в черзі?  Якщо черга обмежена до 3 місць, 
перевіряється, чи є вільне місце в черзі  
Так, є місце  Запит стає в чергу, очікуючи звільнення 
одного з каналів  
Ні, черга заповнена  Якщо черга повна, переходимо до повторного 
виклику  
Повторний виклик?  Чи зробити повторний виклик для запиту?"
6,"Так, повторний виклик  Запит повторно намагається зайти в систему 
після певного часу  
Ні, відмова  Якщо повторний виклик недоступний, запит 
відхиляється системою  
Вихід із системи  Після обслуговування або відмови запит 
виходить із системи  
 
Блок-схема для системи масового обслуговування з повторними викликами та 
очікуванням в черзі з обмеженою кількістю місць (3 місця ), яка обслуговує 1200 заявок і 
має 3 обслуговуючих канали  виглядатиме так:  
*Створювала блок -схему за допомогою сервісу Lucidchart (посилання на блок -схему ) 
 
 
Реалізувати модель в Python, використовуючи SimPy : 
*Лабораторну роботу виконувала у середовищі Google Colab( посилання на нотбук )"
7,"1. Імпорт необхідних бібліотек  
 
 
2. Ініціалізуємо  вихідні  параметри моделі  та змінні для збору 
статистики : 
 
 
3. Створ юємо процес  обслуговування запитів : 
 
 
 

4. Генеруємо  потік запиті в:  
 
 
5. Створ юємо  модел ь та запуск аємо  симуляці ю: 
 
 
Результати моделювання (уривок) :"
8,"1. Обслуговування запитів : 
o Запити обслуговуються  у порядку їх надходження, коли канали вільні. 
Наприклад, запит 0 одразу обслуговується на позначці часу 0.00, запит 1 — 
на 1.97 і так далі.  
o Час обслуговування кожного запиту змінюється, оскільки надходження та 
обслуговування запитів слідує випадковому роз поділу.  
2. Формування черги : 
o Початкові запити (0 –45) обслуговуються без затримок, оскільки в системі 
вистачає ресурсів.  
o Починаючи з запиту 46  (який очікує в черзі у 48.18  та обслуговується у 
49.18 ), черга починає заповнюватися через обмеженість ресурсів, оскі льки 
канали вже зайняті.  
o Деякі запити після заповнення черги не можуть одразу потрапити на 
обслуговування. Запити 493, 494, 496, 497  роблять повторні виклики, 
оскільки система в цей момент перевантажена, що затримує їх обробку.  
3. Повторні виклики : 
o Коли запит и не можуть зайняти канал через перевантаженість або заповнену"
9,"чергу, вони повторно пробують отримати доступ через певний інтервал 
часу.  
o Повторні виклики відбуваються, наприклад, у запитів 493, 494, і 497, які 
спершу не змогли отримати обслуговування, але повторно намагаються це 
зробити, поки нарешті не отримують доступ."
10,"Аналіз навантаження  
1. Пропускна здатність системи : 
o На початку моделювання система ефективно обробляє запити, 
використовуючи доступні канали.  
o При збільшенні кількості запитів і часу моделювання система досягає свого 
навантаження, що призводить до черг і повторних викликів.  
2. Середній час обслуговування та черги : 
o Система має обмежену здатність обробляти запити одночасно, тому із часом 
зростає середня довжина черги.  
o Середній час очікуванн я в черзі та кількість повторних викликів показують, 
наскільки система наближається до своєї межі ефективної роботи.  
 
Внести корективи в програмний код для отримання 
наступних результатів:  
 
1. Дослідити параметри загальної черги:  
- середнє значення довжини  черги,  
- максимальну довжину черги,  
- розподіл довжини черги (відобразити графічно)  
- середній час перебування заявки в черзі  
- максимальний час перебування заявки в черзі  
 
2.  Дослідити кількість повторних викликів  (Для тих СМО, яким це необхідно)."
11,"Визначити, скільки в середньому викликів робить користувач, аби бути 
обслуженим . 
 
3.  Зібрану статистику по попередній програмі  (з різними результатами ситуацій)  
представити графічно в вигляді гістограми.  
 
4. Дослідити параметри черг до кожного з каналів (параметри такі ж як п.1)  
 
5.  Дослідити залежність кількості відмов в обслуговуванні та кількості 
повторних  викликів від росту інтенсивності вхідного потоку заявок  - 
збільшити інтенсивність вхідного потоку  
- 1х 
- 2х 
- 5х 
- 10х 
- 20х 
- 50х 
- 100х  
Щоб виконати всі вимоги, внесемо такі корективи в код:  
1. Збір та обчислення статистики черги  (середня та максимальна довжина черги, 
час перебування заявок у черзі).  
2. Аналіз повторних викликів  (середня кількість повторних спроб на одну заявку).  
3. Графічне представлення результатів  (гіст ограми для довжини черги та 
повторних викликів).  
4. Дослідження параметрів черг до кожного каналу . 
5. Моделювання для різних інтенсивностей вхідного потоку ."
12,"Модифікований код:  
import simpy 
import random 
import numpy as np 
import matplotlib.pyplot as plt 
 
# Вихідні параметри  
NUM_REQUESTS = 500  
NUM_CHANNELS = 3 
QUEUE_CAPACITY = 3 
RETRY_DELAY = 1 
 
# Змінні для збору статистики  
queue_lengths = []  
time_in_queue = []  
retry_counts = []  
failed_requests = 0  # Лічильник для відмов  
 
def request_service (env, request_i d, server, queue, retry_counts ): 
    """"""Процес обробки запиту з повторними викликами, обмеженою чергою і можливими відмовами.""""""  
    global failed_requests  
    arrival_time = env.now  
    retry_count = 0 
    while True: 
        with server.request() as req: 
            result = yield req | env.timeout(RETRY_DELAY)  
            if req in result:  # Якщо запит обслуговується  
                wait_time = env.now - arrival_time  
                time_in_queue.append(wait_time)  
                queue_lengths.append( len(queue.items))"
13,"print(f""Запит {request_id}  обслуговується у {env.now :.2f}, після очікування 
{wait_time :.2f}"") 
                yield env.timeout(random.expovariate( 1.0)) 
                break 
            elif len(queue.items) < QUEUE_CAPACITY:  # Якщо є місце в черзі  
                queue_lengths.append( len(queue.items))  
                queue.put(request_id)  
                yield env.timeout(RETRY_DELAY)  
            else:  # Якщо черга заповнена і потрібно відмовити  
                retry_count += 1 
                retry_counts.append(retry_count)  
                failed_requests += 1  # Фіксуємо відмову  
                print(f""Запит {request_id}  відхилено у {env.now :.2f} після {retry_count}  
повторних спроб."" ) 
                break 
 
def generate_requests (env, server, queue, intensity_multiplier ): 
    """"""Генератор запитів з інтервалом прибуття, враховуючи множник інтенсивності.""""""  
    for i in range(NUM_REQUESTS):"
14,"for i in range(NUM_REQUESTS):  
        env.process(request_service(env, i, server, queue, retry_counts )) 
        # Застосовуємо множник до інтенсивності, зменшуючи час між запитами  
        yield env.timeout(random.expovariate( 1.0 * intensity_multiplier))  
 
def analyze_statistics (): 
    """"""Аналіз і виведення статистики для черги, повторних викликів і відмов. """""" 
    print(""\nЗАГАЛЬНА СТАТИСТИКА ЧЕРГИ"" ) 
 
    if queue_lengths:  
        print(f""Середня довжина черги: {np.mean(queue_lengths) :.2f}"") 
        print(f""Максимальна довжина черги: {np.max(queue_lengths) :.2f}"") 
    else: 
        print(""Середня довжина черги: N/A"" ) 
        print(""Максимальна довжина черги: N/A"" ) 
 
    if time_in_queue:  
        print(f""Середній час перебування в черзі: {np.mean(time_in_queue) :.2f}"") 
        print(f""Максимальний час перебування в черзі: {np.max(time_in_queue) :.2f}"") 
    else: 
        print(""Середній час перебування в черзі: N/A"" )"
15,"print(""Максимальний час перебування в черзі: N/A"" ) 
 
    if retry_counts:  
        print(f""Середня кількість повторних викликів: {np.mean(retry_counts) :.2f}"") 
        print(f""Максимальна кількість повторних викликів для одного запиту: 
{np.max(retry_counts) :.2f}"") 
    else: 
        print(""Середня кількість повторних викликів: N/A"" ) 
        print(""Максимальна кількість повторних викликів для одного запиту: N/A"" ) 
 
    print(f""Кількість відмов : {failed_requests} "") 
 
def plot_histogram (data, title, xlabel, ylabel): 
    """"""Функція для побудови гістограми.""""""  
    plt.figure(figsize=( 10, 6)) 
    plt.hist(data, bins= 20, color= 'skyblue' , edgecolor= 'black') 
    plt.title(title)  
    plt.xlabel(xlabel)  
    plt.ylabel(ylabel)  
    plt.show()  
 
# Основна функція моделювання  
def run_simulation (intensity_multiplier =1): 
    global queue_lengths, time_in_queue, retry_counts, failed_requests  
    queue_lengths = []  
    time_in_queue = []"
16,"queue_lengths = []  
    time_in_queue = []  
    retry_counts = []  
    failed_requests = 0 
     
    # Ініціалізація середовища та ресурсів  
    env = simpy.Environment()  
    server = simpy.Resource(env, capacity=NUM_CHANNELS)  
    queue = simpy.Store(env, capacity=QUEUE_CAPACITY)  
     
    # Запуск генерації запитів  
    env.proc ess(generate_requests(env, server, queue, intensity_multiplier))  
    env.run()  
 
    # Виведення статистики  
    analyze_statistics()  
 
    # Графічне представлення  
    if queue_lengths:  
        plot_histogram(queue_lengths, ""Розподіл довжини черги"" , ""Довжина  черги"", ""Кількість"" ) 
    else: 
        print(""Немає даних для побудови гістограми довжини черги."" ) 
     
    if time_in_queue:  
        plot_histogram(time_in_queue, ""Розподіл часу перебування в черзі"" , ""Час у черзі"" , 
""Кількість запитів"" ) 
    else: 
        print(""Немає даних для побудови гістограми часу перебування в черзі."" ) 
     
    if retry_counts:"
17,"if retry_counts:  
        plot_histogram(retry_counts, ""Розподіл повторних викликів"" , ""Кількість повторних 
викликів"" , ""Кількість запитів"" ) 
    else: 
        print(""Немає даних д ля побудови гістограми повторних викликів."" ) 
 
# Запуск моделювання для 100x інтенсивності  
print(""\nМоделювання з інтенсивністю потоку: 100x"" ) 
run_simulation(intensity_multiplier= 100) 
 
 
 
Моделювання з інтенсивністю потоку  1x:"
18,"Немає даних для побудови гістограми повторних викликів , так як їх не було  
 
 
Моделювання з інтенсивністю потоку  2x: 

 
 

 
 

 
 
 
Моделювання з інтенсивністю потоку  5x: 
 

 
 
 

 
 
 

Моделювання з інтенсивністю потоку  10x: 
 
 
 

 
 

 
Моделювання з інтенсивністю потоку  20x: 
 
 
 
 

 
 

 
Моделювання з інтенсивністю потоку  50x: 
 
 
 

 
 
 

Моделювання з інтенсивністю потоку  100x:"
19,"Модифікація коду полягала у додаванні детальної статистики щодо черг і повторних викликів. 
Зокрема, було додано обчислення середньої та максимальної довжини черги, часу перебування 
заявки в черзі, а також середньої кількості повторних спроб на одну заявку. Окрім того, 
дослідження було розширене аналізом залежності параметрів від інтенсивності вхідного потоку. 
Це дало змогу оцінити, як змін юються параметри черги і кількість відмов за збільшення 
навантаження на систему.  
З графічного аналізу (гістограми розподілу черги, часу перебування в черзі та кількості повторних 
викликів) видно, що при низьких значеннях інтенсивності (наприклад, 1x) черга  не накопичується 
і повторних викликів практично немає. Однак зі збільшенням інтенсивності до 10x і більше 
кількість відмов і повторних спроб суттєво зростає. Це вказує на те, що система має межу 
ефективності, за якою накопичення черги і відмови стають зна чними, що може призвести до 
значного зниження якості обслуговування."
20,"значного зниження якості обслуговування.  
 1. Середня та максимальна довжина черги  
При збільшенні інтенсивності вхідного потоку (наприклад, у 2x, 5x, 10x разів) середня та 
максимальна довжина черги значно зростають. Це свідчить п ро те, що система швидко досягає 
межі своєї пропускної здатності, і черга починає переповнюватися. За низької інтенсивності 
потоку система підтримує коротку чергу, що вказує на достатню кількість ресурсів для обробки 
запитів у звичайному режимі.  
 
При висок их інтенсивностях, таких як 50x або 100x, максимальна довжина черги стає значно 
більшою за середню, що означає періодичні пікові навантаження, які система не може обробити"
21,"вчасно. Це також демонструє, що за значних перевантажень відбувається накопичення за питів до 
критичних рівнів, що призводить до затримок у роботі системи.  
 
2. Середній і максимальний час перебування заявки в черзі  
Із зростанням інтенсивності потоку середній час перебування заявки в черзі також значно 
збільшується. За низьких значень інтенсивності (1x, 2x) середній час очікування в черзі є 
незначним, оскільки запити обробляються майже відразу. Проте при збільшенні інтенсивності 
часу перебування зростає нелінійно, що свідчить про обмеження системи при обробці великої 
кількості запитів.  
 
Максимальний час перебування в черзі особливо великий при високих інтенсивностях, що 
показує, наскільки сильно може затримуватися обробка запитів у пікові моменти. Це є критичним 
для користувачів, оскільки надмірний час очікування погіршує досвід користув ача і може 
призвести до втрати запитів, які так і не дочекалися обслуговування."
22,"3. Середня кількість повторних спроб на одну заявку  
При низькій інтенсивності потоку повторні спроби є рідкісними або відсутніми, що вказує на 
нормальну роботу системи без не обхідності повторних викликів. Проте при інтенсивностях від 
10x і вище середня кількість повторних спроб на одну заявку починає різко зростати. Це свідчить 
про те, що користувачі змушені повторно подавати запити через переповненість черги, що може 
бути озн акою того, що система досягла своєї межі обслуговування.  
 
При дуже високих інтенсивностях, таких як 50x чи 100x, кількість повторних спроб стає значною, 
що призводить до додаткового навантаження на систему і може створювати ще більші черги. Така 
ситуація в казує на те, що система не справляється з обробкою запитів, що надходять, що 
негативно позначається на ефективності обслуговування.  
 
Загальний висновок  
Загалом, зростання інтенсивності вхідного потоку призводить до суттєвого збільшення довжини"
23,"черги, часу перебування заявок у черзі та кількості повторних спроб. Це вказує на потребу в 
масштабуванні системи або збільшенні її пропускної здатності для запобігання критичним 
затримкам та відмовам в обслуговуванні при високих навантаженнях.  
 
Виснов ок: у ході викон ання даної лабораторної роботи було досліджено поведінку 
систем масового обслуговування за допомогою бібліотеки SimPy у Python. Основна задача 
полягала у моделюванні системи, яка могла б обробляти вхідні запити в умовах обмеженої 
кількості обслуговуючих ка налів і місць у черзі. Для реалізації було обрано варіант СМО з 
повторними викликами і обмеженою кількістю місць у черзі, що дозволило змоделювати 
процес пошуку збоїв у банківській мережі.  
У результаті моделювання були отримані показники, які допомагають о цінити 
продуктивність системи в умовах різного навантаження, зокрема такі, як середня та 
максимальна довжина черги, кількість відмов, кількість повторних викликів, а також"
24,"розподіл часу очікування запитів у черзі. Ці показники є важливими для аналізу 
наван таження і визначення меж ефективної роботи системи."
